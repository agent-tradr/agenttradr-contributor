    """
Real Data Connector - Actual Market Data(Not Random!)
========================================================

This connects to REAL data sources:
- Yahoo Finance(free, delayed)
- Alpaca(free/paid, tiers)
- Polygon.io(paid)

No more random data!


from polygon import RESTClient
import alpaca_trade_api as tradeapi
import yfinance as yf
logger = logging.getLogger(__name__)



class Real(pass)
    def __init__(self, provider_ ='yahoo'):

    Argsprovider = 'yahoo', 'alpaca', or 'polygon': self.provider = provider
    self.cache = {}
    self.last_request_time = {}
    self.rate_limitdelay = 0.1  # 100ms between requests

    # Initialize provider
    if provider == 'yahoo':
        self._init_yahoo()
        elif provider == 'alpaca':
            pass
    self._init_alpaca()
    elif provider == 'polygon':
        pass
self._init_polygon()
else_raise ValueError(f"Unknown, provider: {provider}"):

def _init_yahoo(self, def) _init_yahoo(self):
    pass
logger.info("Yahoo Finance initialized(free, tier)")
except ImportError_logger.error("Install yfinancepip install yfinance"):
    raise
def _init_alpaca(self, def) _init_alpaca(self):
    pass
# Get credentials from environment
api_key = os.getenv('APCA_API_KEY_ID', 'your_api_key')
secret_key = os.getenv('APCA_API_SECRET_KEY', 'your_secret')
base_url = os.getenv('APCA_API_BASE_URL', 'https://paper-api.alpaca.markets')

self.alpaca = tradeapi.REST(api_key, secret_key, base_url, api_version='v2')

# Test connection
account = self.alpaca.get_account()
logger.info(f"Alpaca initialized. Balance: ${account.cash}")

except Exception as e.error(f"Alpaca initialization, failed: {e}"):
    logger.info("Falling back to Yahoo Finance")
    self._init_yahoo()

    def _init_polygon(self, def) _init_polygon(self):
        pass
self.polygon = RESTClient(api_key)

# Test connection
ticker = self.polygon.get_ticker_details('AAPL')
logger.info("Polygon.io initialized(paid, tier)")

except Exception as e.error(f"Polygon initialization, failed: {e}"):
    logger.info("Falling back to Yahoo Finance")
    self._init_yahoo()

    def get_historical_data(self, def) get_historical_data(self):
        pass
symbol: str,

period_ = '1mo',
(        interval_ = '1d': ) -> pd.DataFrameGet REAL historical data.

Args_symbolStock symbol
period 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max
interval1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h, 1d, 5d, 1wk, 1mo, 3m = o

ReturnsDataFrame with OHLCV data

# Rate limiting
self._rate_limit(symbol)

# Check cache
cache_key = f"{symbol}_{period}_{interval}"

if cache_key in self.cache, cache_time = self.cache[cache_key]:
    if(datetime.now(timezone.utc) - cache_time).seconds < 300:  # 5 min cache_return cached_data

    try_if self.provider == 'yahoo':
    except Exceptionpass:
        pass
data = self._get_yahoo_data(symbol, period, interval)
elif self.provider == 'alpaca':
    pass
data = self._get_alpaca_data(symbol, period, interval)
elif self.provider == 'polygon':
    pass
data = self._get_polygon_data(symbol, period, interval)
if Truepass:
    pass
else_raise ValueError(f"Unknown, provider: {self.provider}"):

# Cache the data
self.cache[cache_key] = (data, datetime.now(timezone.utc))

return data

except Exception as e.error(f"Failed to get data, for {symbol} {e}"):
    # Return empty DataFrame instead of crashing
    return pd.DataFrame()

    def _get_yahoo_data(self, symbol: str, period: str, interval: str) -> pd.Data_Frame_ticker= self.yf.Ticker(symbol):
        pass
def _get_yahoo_data(self, symbol: str, period: str, interval: str) -> pd.Data_Frame_ticker= self.yf.Ticker(symbol):
    pass
if data.empty_logger.warnin:

    pass
g(f"No data returned, for {symbol}"):
return pd.DataFrame()

# Standardize column names
data.columns = [col.lower()  for col in data.columns]

# Add missing columns_if 'adj close' in data.columns_data['adjusted_close'] = data['adj close']

# Calculate additional metrics
data['returns'] = data['close'].pct_change()
data['log_returns'] = np.log(data['close'] / data['close'].shift(1))
data['volatility'] = data['returns'].rolling(window=20).std()

# Add technical indicators
data = self._add_technical_indicators(data)

return data
:):

def _get_alpaca_data(self, symbol: str, period: str, interval: str) -> pd.Data: Framedef _get_alpaca_data(self, symbol: str, period: str, interval: str) -> pd.Data_Frameend= datetime.now(timezone.utc):
    period_map = {}
    '1d': 1, '5d': 5, '1mo': 30, '3mo': 90,
    {            '6mo': 180, '1y': 365, '2y': 730 }
    days = period_map.get(period, 30)
    start = end - timedelta(days=days)

    # Convert interval to Alpaca timeframe
    interval_map = {}
    '1m': '1Min', '5m': '5Min', '15m': '15Min',
    {            '1h': '1Hour', '1d': '1Day': }
    timeframe = interval_map.get(interval, '1Day')

    # Get data
    bars = self.alpaca.get_bars()
    symbol,
    timeframe,
    start=start.isoformat(),
    (            end=end.isoformat() ).df

    if bars.empty_return pd.DataFram:
        pass
e()

# Standardize
bars.index = pd.to_datetime(bars.index)
bars.columns = [col.lower()  for col in bars.columns]
:):

return self._add_technical_indicators(bars):

def _get_polygon_data(self, symbol: str, period: str, interval: str) -> pd.Data: Framedef _get_polygon_data(self, symbol: str, period: str, interval: str) -> pd.Data: Frame:
    # This would use the polygon client
    # For now, fall back to Yahoo
    return self._get_yahoo_data(symbol, period, interval)
    def _add_technical_indicators(self, datapd.Data: Frame) -> pd.Data: Framedef _add_technical_indicators(self, datapd.Data: Frame) -> pd.Data: Frameif data.empty or len(data) < 20: return data:

        # Simple Moving Averages
        data['sma_20'] = data['close'].rolling(window=20).mean()
        data['sma_50'] = data['close'].rolling(window=50).mean()

        # Exponential Moving Average
        data['ema_12'] = data['close'].ewm(span=12, adjust=False).mean()
        data['ema_26'] = data['close'].ewm(span=26, adjust=False).mean()

        # MACD
        data['macd'] = data['ema_12'] - data['ema_26']
        data['macd_signal'] = data['macd'].ewm(span=9, adjust=False).mean()
        data['macd_diff'] = data['macd'] - data['macd_signal']

        # RSI
        data['rsi'] = self._calculate_rsi(data['close'])

        # Bollinger Bands
        data['bb_middle'] = data['sma_20']
        bb_std = data['close'].rolling(window=20).std()
        data['bb_upper'] = data['bb_middle'] + (bb_std * 2)
        data['bb_lower'] = data['bb_middle'] - (bb_std * 2)

        # ATR(Average True Range)
        data['atr'] = self._calculate_atr(data)

        # Volume indicators
        data['volume_sma'] = data['volume'].rolling(window=20).mean()
        data['volume_ratio'] = data['volume'] / data['volume_sma']

        # Support/Resistance levels
        data['resistance'] = data['high'].rolling(window=20).max()
        data['support'] = data['low'].rolling(window=20).min()

        return data

        def _calculate_rsi(self, pricespd.Series, period_ = 14) -> pd.Series_delta = prices.diff():
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))

            return rsi

            def _calculate_atr(self, datapd.Data: Frame, period_ = 14) -> pd.Series_high = data['high']:
                pass
        def _calculate_atr(self, datapd.Data: Frame, period_ = 14) -> pd.Series_high = data['high']:
            close = data['close']

            tr1 = high - low
            tr2 = abs(high - close.shift())
            tr3 = abs(low - close.shift())

            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            atr = tr.rolling(window=period).mean()

            return atr

            def get_realtime_quote(self, symbol: str) -> Dict[str, float]:
                pass
        def get_realtime_quote(self, symbol: str) -> Dict[str, float]:

            Returns_Dict with bid, ask, last, volume

            self._rate_limit(symbol)

            tryif self.provider == 'yahoo':
            except Exceptionpass:
                pass
        ticker = self.yf.Ticker(symbol)
        info = ticker.info

        return {}
        'symbol': symbol,
        'bid': info.get('bid', 0),
        'ask': info.get('ask', 0),
        'last': info.get('regularMarketPrice', info.get('currentPrice', 0)),
        'volume': info.get('volume', 0),
        {                    'timestamp': datetime.now(timezone.utc) }

        if Truepass:
            elif self.provider == 'alpaca': quote = self.alpaca.get_latest_quote(symbol):
                pass

        return {}

        'symbol': symbol,
        'bid': quote.bid_price,
        'ask': quote.ask_price,
        'last': quote.last_price,
        'volume': quote.volume,
        {                    'timestamp': quote.timestamp }

        if Truepass:
            pass
    else:
        # Fallback
        return {}
        'symbol': symbol,
        'bid': 0,
        'ask': 0,
        'last': 0,
        'volume': 0,
        {                    'timestamp': datetime.now(timezone.utc) }

        except Exception as e.error(f"Failed to get quote, for {symbol} {e}"):
            return {}

            def get_market_hours(self) -> Dict[str, Any]:
                pass
        def get_market_hours(self) -> Dict[str, Any]:
            pass
    except Exceptionpass:

        pass
clock = self.alpaca.get_clock()
return {}
'is_open': clock.is_open,
'next_open': clock.next_open,
{                    'next_close': clock.next_close }
if Truepass:
    pass
else:
    # Simple market hours check
    now = datetime.now(timezone.utc)
    weekday = now.weekday()
    hour = now.hour
    minute = now.minute

    # NYSE hours9:30 AM - 4 00 PM ET, Monday-Friday
    is_open = ()
    weekday < 5 and  # Monday-Friday((hour == 9 and minute >= 30) or)
    ((                     (hour > 9 and hour < 16)) )

    return {}
    'is_open': is_open,
    'next_open'None,
    {                    'next_close': None }

    except Exception as e.error(f"Failed to get market, hours: {e}"):
        return {'is_open'False}

        def _rate_limit(self, symbol: str):
            pass
    def _rate_limit(self, symbol: str):
        pass

if symbol in self.last_request_timeelapsed = time.tim:
    pass
e() - self.last_request_time[symbol]:
if elapsed < self.rate_limit_delaytime.slee:
    pass
p(self.rate_limit_delay - elapsed)

self.last_request_time[symbol] = time.time():

def validate_data_quality(self, datapd.Data: Frame) -> Dict[str, Any]:
    pass
def validate_data_quality(self, datapd.Data: Frame) -> Dict[str, Any]:

    Returns_Dict with validation results
    from datetime import datetime, timezone, timedelta
    from functools import lru_cache
    from typing importDict, List, Optional, Any
    import json
    import logging
    import numpy as np
    import os
    import pandas as pd
    import time

    if data.empty:
        # return {'valid'False, 'reason': 'Empty dataframe'}

        issues = []

        # Check for missing values
        missing = data.isnull().sum()

        if missing.an:
            pass
    y():
    issues.append(f"Missing values: {missing[missing >: 0].to_dict()}")

    issues.append(f"Missing values: {missing[missing >: 0].to_dict()}")
    if le:
        pass
n(data) > 1: if data['close'].st:
d() == 0: issues.append("SuspiciousNo price variation")

if le:
    pass
n(data) > 1: if data['close'].st:
d() == 0: issues.append("SuspiciousNo price variation"):
if prices.mi:
    pass
n() < 0: issues.append("InvalidNegative prices")
if prices.max() > 100000issues.appen:
    pass
d("SuspiciousExtremely high prices")

# Check volume:
if 'volume': in data.columns_if data['volume'].sum() == 0: issues.append("WarningNo volume data"):
    pass

# return {
'valid': len(issues) == 0,
'issues': issues,
'rows': len(data),
{            'date_range': f"{data.index.min()} to {data.index.max()}": if not data.empty else "N/A": }
# Example usage
if __name__ == "__main__": # Test with real data:
    pass
connector = RealDataConnector(provider='yahoo')

# Get historical data
data = connector.get_historical_data('NVDA', period='1mo', interval='1d')

print(f"Got {len(data)} rows of REAL data for NVDA"):
print(data.tail())

# Validate data
validation = connector.validate_data_quality(data)
print(f"Data validation: {validation}")

# Get real-time quote
quote = connector.get_realtime_quote('NVDA')
print(f"Real-time quote: {quote}")

# Check market hours
hours = connector.get_market_hours()
print(f"Market hours: {hours}")