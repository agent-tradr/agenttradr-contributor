"""
Stock Universe Initializer - Creates and maintains the tradeable stock universe.

This module initializes the universe with 150-200 quality stocks across
sectors and themes, with quality screening and classification.
"""




class QualityRating:
    """Quality rating levels for stocks."""
    EXCELLENT = "EXCELLENT"     # A+ rating
    GOOD = "GOOD"              # A rating  
    FAIR = "FAIR"              # B rating
    POOR = "POOR"              # C rating
    EXCLUDED = "EXCLUDED"      # Not tradeable


class MarketCap:
        pass
    """Market capitalization categories."""
    MEGA = "MEGA"              # $200B+
    LARGE = "LARGE"            # $10B-$200B
    MID = "MID"                # $2B-$10B
    SMALL = "SMALL"            # $300M-$2B
    MICRO = "MICRO"            # Under $300M


@dataclass
class StockInfo:
    pass
    """Complete stock information."""
    symbol: str
    name: str
    sector: str
    industry: str
    market_cap: float
    market_cap_category: MarketCap
    price: float
    volume: float
    avg_volume_30d: float
    pe_ratio: Optional[float]
    forward_pe: Optional[float]
    peg_ratio: Optional[float]
    price_to_book: Optional[float]
    debt_to_equity: Optional[float]
    roe: Optional[float]
    revenue_growth: Optional[float]
    earnings_growth: Optional[float]
    beta: Optional[float]
    dividend_yield: Optional[float]
    quality_rating: QualityRating
    quality_score: float
    themes: List[str]
    exchange: str
    currency: str
    country: str
    employees: Optional[int]
    website: Optional[str]
    description: Optional[str]
    created_at: datetime
    updated_at: datetime
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            'symbol': self.symbol,
            'name': self.name,
            'sector': self.sector,
            'industry': self.industry,
            'market_cap': self.market_cap,
            'market_cap_category': self.market_cap_category.value,
            'price': self.price,
            'volume': self.volume,
            'avg_volume_30d': self.avg_volume_30d,
            'pe_ratio': self.pe_ratio,
            'forward_pe': self.forward_pe,
            'peg_ratio': self.peg_ratio,
            'price_to_book': self.price_to_book,
            'debt_to_equity': self.debt_to_equity,
            'roe': self.roe,
            'revenue_growth': self.revenue_growth,
            'earnings_growth': self.earnings_growth,
            'beta': self.beta,
            'dividend_yield': self.dividend_yield,
            'quality_rating': self.quality_rating.value,
            'quality_score': self.quality_score,
            'themes': self.themes,
            'exchange': self.exchange,
            'currency': self.currency,
            'country': self.country,
            'employees': self.employees,
            'website': self.website,
            'description': self.description,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat() }


class UniverseInitializer:
        pass
    """
    Initializes and maintains the stock universe with quality screening.
    
    Creates a curated universe of 150-200 quality stocks across sectors
    and themes, with comprehensive fundamental analysis and classification.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.data_manager = StockDataManager(db_manager)
        self.logger = logging.getLogger(__name__)
        
        # Universe parameters
        self.target_universe_size = 175  # Target number of stocks
        self.min_market_cap = 1_000_000_000  # $1B minimum
        self.min_avg_volume = 100_000  # 100k shares daily minimum
        self.min_price = 5.0  # $5 minimum price
        self.max_price = 1000.0  # $1000 maximum price
        
        # Quality thresholds
        self.quality_thresholds = {
            'min_revenue_growth': -0.10,  # -10% minimum
            'max_pe_ratio': 50.0,
            'min_roe': 0.10,  # 10% minimum ROE
            'max_debt_to_equity': 2.0,
            'min_liquidity_score': 0.3 }
        
        # Base universe - Core S&P 500 stocks by sector
        self.base_universe = {
            'technology': [
                'AAPL', 'MSFT', 'GOOGL', 'GOOG', 'META', 'NVDA', 'TSLA', 'NFLX',
                'ADBE', 'CRM', 'ORCL', 'INTC', 'AMD', 'QCOM', 'AVGO', 'TXN',
                'MU', 'AMAT', 'LRCX', 'ADI', 'KLAC', 'MCHP', 'SNPS', 'CDNS' ],
            'healthcare': [
                'JNJ', 'PFE', 'ABBV', 'MRK', 'UNH', 'LLY', 'TMO', 'DHR',
                'ABT', 'BMY', 'AMGN', 'GILD', 'MDT', 'CI', 'CVS', 'ANTM',
                'HUM', 'ISRG', 'REGN', 'VRTX', 'BIIB', 'MRNA', 'ZTS', 'DXCM' ],
            'financials': [
                'JPM', 'BAC', 'WFC', 'GS', 'MS', 'C', 'USB', 'TFC',
                'PNC', 'COF', 'AXP', 'BLK', 'SCHW', 'CB', 'ICE', 'SPGI',
                'MCO', 'CME', 'AON', 'MMC', 'AJG', 'BRO', 'TRV', 'ALL' ],
            'consumer_discretionary': [
                'AMZN', 'HD', 'NKE', 'MCD', 'DIS', 'SBUX', 'LOW', 'TJX',
                'BKNG', 'TGT', 'GM', 'F', 'TSLA', 'EBAY', 'ETSY', 'LULU',
                'RCL', 'CCL', 'MAR', 'HLT', 'MGM', 'WYNN', 'LVS', 'NCLH' ],
            'consumer_staples': [
                'PG', 'KO', 'WMT', 'COST', 'PEP', 'MDLZ', 'CL', 'KMB',
                'GIS', 'K', 'HSY', 'CPB', 'SJM', 'CAG', 'KHC', 'TSN',
                'MNST', 'KDP', 'CLX', 'CHD', 'MKC', 'SYY', 'ADM', 'BG' ],
            'industrials': [
                'BA', 'CAT', 'GE', 'MMM', 'HON', 'UNP', 'LMT', 'RTX',
                'UPS', 'FDX', 'NOC', 'DE', 'WM', 'EMR', 'ETN', 'PH',
                'CMI', 'ITW', 'GWW', 'DOV', 'ROK', 'XYL', 'FAST', 'PAYX' ],
            'materials': [
                'LIN', 'APD', 'FCX', 'NEM', 'DOW', 'DD', 'ECL', 'SHW',
                'NUE', 'VMC', 'MLM', 'PKG', 'IFF', 'PPG', 'CF', 'FMC',
                'ALB', 'CE', 'IP', 'WRK', 'SEE', 'AVY', 'BLL', 'CCK' ],
            'energy': [
                'XOM', 'CVX', 'COP', 'SLB', 'EOG', 'PXD', 'KMI', 'OKE',
                'WMB', 'EPD', 'MPC', 'VLO', 'PSX', 'HES', 'DVN', 'FANG',
                'BKR', 'HAL', 'APA', 'EQT', 'TRGP', 'OXY', 'MRO', 'ATO' ],
            'utilities': [
                'NEE', 'DUK', 'SO', 'D', 'EXC', 'AEP', 'XEL', 'PEG',
                'SRE', 'PCG', 'ED', 'EIX', 'WEC', 'AWK', 'DTE', 'ES',
                'AEE', 'CMS', 'NI', 'LNT', 'EVRG', 'PNW', 'FE', 'CNP' ],
            'real_estate': [
                'AMT', 'CCI', 'PLD', 'EQIX', 'PSA', 'EQR', 'WELL', 'DLR',
                'BXP', 'AVB', 'EXR', 'UDR', 'ESS', 'MAA', 'HST', 'REG',
                'FRT', 'KIM', 'BRX', 'CPT', 'AIV', 'ELS', 'UMH', 'AHH' ],
            'communication': [
                'GOOGL', 'META', 'DIS', 'CMCSA', 'VZ', 'T', 'NFLX', 'CHTR',
                'TMUS', 'ATVI', 'EA', 'TTWO', 'MTCH', 'PINS', 'SNAP', 'TWTR',
                'DISH', 'SIRI', 'LBRDK', 'LBRDA', 'LILAK', 'LILA', 'CABO', 'IRDM' ] }
        
        # Theme classifications
        self.theme_classifications = {
            'ai_machine_learning': [
                'NVDA', 'GOOGL', 'MSFT', 'META', 'AMD', 'INTC', 'IBM', 'ORCL',
                'CRM', 'PLTR', 'AI', 'SNOW', 'PATH', 'DDOG', 'MDB', 'OKTA' ],
            'clean_energy': [
                'TSLA', 'NEE', 'ENPH', 'SEDG', 'FSLR', 'BEP', 'ICLN', 'TAN',
                'PLUG', 'BE', 'QS', 'CHPT', 'BLNK', 'RUN', 'NOVA', 'SPWR' ],
            'cybersecurity': [
                'CRWD', 'ZS', 'OKTA', 'FTNT', 'PANW', 'CYBR', 'FEYE', 'SPLK',
                'RPD', 'TENB', 'S', 'NET', 'PFPT', 'QLYS', 'VRNS', 'SAIL' ],
            'cloud_computing': [
                'MSFT', 'AMZN', 'GOOGL', 'CRM', 'NOW', 'SNOW', 'MDB', 'DDOG',
                'NET', 'FSLY', 'ESTC', 'ZM', 'WORK', 'TEAM', 'ATLASSIAN', 'ZEN' ],
            'electric_vehicles': [
                'TSLA', 'NIO', 'RIVN', 'LCID', 'F', 'GM', 'XPEV', 'LI',
                'FISV', 'GOEV', 'RIDE', 'NKLA', 'HYLN', 'QS', 'CHPT', 'BLNK' ],
            'biotechnology': [
                'GILD', 'BIIB', 'MRNA', 'REGN', 'AMGN', 'VRTX', 'ILMN', 'ALXN',
                'CELG', 'BMRN', 'SGEN', 'INCY', 'EXAS', 'ARKG', 'XBI', 'IBB' ],
            'fintech': [
                'SQ', 'PYPL', 'COIN', 'AFRM', 'SOFI', 'UPST', 'LMND', 'HOOD',
                'LC', 'ONDK', 'PAGS', 'STNE', 'NU', 'MELI', 'FUTU', 'TIGR' ],
            'semiconductor': [
                'NVDA', 'AMD', 'INTC', 'QCOM', 'AVGO', 'TSM', 'MU', 'TXN',
                'AMAT', 'LRCX', 'ADI', 'KLAC', 'MCHP', 'SNPS', 'CDNS', 'ASML' ],
            'streaming_media': [
                'NFLX', 'DIS', 'PARA', 'WBD', 'ROKU', 'SPOT', 'FUBO', 'SIRI',
                'LYV', 'MSG', 'MSGS', 'IMAX', 'CNK', 'AMC', 'PLBY', 'REZI' ],
            'space_aerospace': [
                'BA', 'LMT', 'NOC', 'RTX', 'GD', 'TXT', 'KTOS', 'AJRD',
                'RKLB', 'SPCE', 'MAXR', 'IRDM', 'GILT', 'AVAV', 'CW', 'MOG.A' ] }
    
        async def initialize_universe(self, force_refresh: bool = False) -> Dict[str, Any]:
        """
        Initialize the complete stock universe with quality screening.
        
        Args:
            force_refresh: Force refresh of all data
            
        Returns:
            Universe initialization results
        """
        try:
            self.logger.info("Starting universe initialization...")
            
            # Get all candidate symbols
            all_symbols = self._get_all_candidate_symbols()
            self.logger.info(f"Analyzing {len(all_symbols)} candidate symbols")
            
            # Fetch and analyze stock data
            analyzed_stocks = await self._analyze_stocks_batch(all_symbols, force_refresh)
            
            # Apply quality screening
            quality_stocks = self._apply_quality_screening(analyzed_stocks)
            
            # Select final universe
            final_universe = self._select_final_universe(quality_stocks)
            
            # Store in database
            await self._store_universe(final_universe)
            
            # Generate summary statistics
            summary = self._generate_universe_summary(final_universe)
            
            self.logger.info(
                f"Universe initialization complete: {len(final_universe)} stocks selected" )
            
            return {
                'success': True,
                'universe_size': len(final_universe),
                'quality_breakdown': summary['quality_breakdown'],
                'sector_breakdown': summary['sector_breakdown'],
                'theme_breakdown': summary['theme_breakdown'],
                'market_cap_breakdown': summary['market_cap_breakdown'],
                'created_at': datetime.now(timezone.utc).isoformat() }
            
        except Exception as e:
            self.logger.error(f"Failed to initialize universe: {e}")
            return {
                'success': False,
                'error': str(e),
                'universe_size': 0 }
    
            def _get_all_candidate_symbols(self) -> List[str]:
        """Get all candidate symbols from base universe."""
        all_symbols = set()
        
        # Add all base universe symbols
        for sector_symbols in self.base_universe.values():
            all_symbols.update(sector_symbols)
        
        # Add theme-specific symbols
            for theme_symbols in self.theme_classifications.values():
            all_symbols.update(theme_symbols)
        
        # Remove duplicates and return as sorted list
        return sorted(list(all_symbols))
    
    async def _analyze_stocks_batch(
        self, 
        symbols: List[str], 
        force_refresh: bool = False ) -> List[StockInfo]:
        pass
        """Analyze a batch of stocks in parallel."""
                pass
        
        # Process in batches to avoid rate limits
        batch_size = 20
        analyzed_stocks = []
        
    for i in range(0, len(symbols), batch_size):
            batch = symbols[i:i + batch_size]
            
            # Process batch in parallel
            semaphore = asyncio.Semaphore(5)  # Limit concurrent requests
            
        async def analyze_single_stock(symbol: str) -> Optional[StockInfo]:
                async with semaphore:
            return await self._analyze_single_stock(symbol, force_refresh)
            
            tasks = [analyze_single_stock(symbol) for symbol in batch]
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Filter valid results
            valid_results = []
                result for result in batch_results
                if isinstance(result, StockInfo) ]
            
            analyzed_stocks.extend(valid_results)
            
            self.logger.info(
                f"Analyzed batch {i//batch_size + 1}/{(len(symbols)-1)//batch_size + 1}: "
                f"{len(valid_results)}/{len(batch)} valid" )
            
            # Rate limiting delay
            await asyncio.sleep(1)
        
        return analyzed_stocks
    
    async def _analyze_single_stock(
        self, 
        symbol: str, 
        force_refresh: bool = False ) -> Optional[StockInfo]:
        pass
        """Analyze a single stock."""
        try:
            # Get stock data from yfinance
            ticker = yf.Ticker(symbol)
            
            # Get basic info
            info = ticker.info
        if not info or 'symbol' not in info:
            return None
            
            # Get historical data for technical analysis
            hist = ticker.history(period="1y")
            if hist.empty:
                return None
            
            # Calculate current metrics
            current_price = hist['Close'][-1]
            current_volume = hist['Volume'][-1]
            avg_volume_30d = hist['Volume'][-30:].mean()
            
            # Extract fundamental data
            market_cap = info.get('marketCap', 0)
            if market_cap < self.min_market_cap:
                return None
            
            # Get sector classification
            sector = self._classify_sector(symbol, info.get('sector', 'Unknown'))
            industry = info.get('industry', 'Unknown')
            
            # Get theme classifications
            themes = self._get_symbol_themes(symbol)
            
            # Calculate quality metrics
            quality_score, quality_rating = self._calculate_quality_score(info, hist)
            
            # Create StockInfo object
            stock_info = StockInfo(
                symbol=symbol,
                name=info.get('longName', symbol),
                sector=sector,
                industry=industry,
                market_cap=market_cap,
                market_cap_category=self._classify_market_cap(market_cap),
                price=current_price,
                volume=current_volume,
                avg_volume_30d=avg_volume_30d,
                pe_ratio=info.get('trailingPE'),
                forward_pe=info.get('forwardPE'),
                peg_ratio=info.get('pegRatio'),
                price_to_book=info.get('priceToBook'),
                debt_to_equity=info.get('debtToEquity'),
                roe=info.get('returnOnEquity'),
                revenue_growth=info.get('revenueGrowth'),
                earnings_growth=info.get('earningsGrowth'),
                beta=info.get('beta'),
                dividend_yield=info.get('dividendYield'),
                quality_rating=quality_rating,
                quality_score=quality_score,
                themes=themes,
                exchange=info.get('exchange', ''),
                currency=info.get('currency', 'USD'),
                country=info.get('country', 'US'),
                employees=info.get('fullTimeEmployees'),
                website=info.get('website'),
                description=info.get('longBusinessSummary'),
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc) )
            
            return stock_info
            
    except Exception as e:
            self.logger.error(f"Failed to analyze {symbol}: {e}")
            return None
    
            def _classify_sector(self, symbol: str, yf_sector: str) -> str:
        """Classify symbol into our sector taxonomy."""
        
        # First try our predefined mappings
        for sector, symbols in self.base_universe.items():
            if symbol in symbols:
                return sector
        
        # Fallback to yfinance sector with mapping
        sector_mapping = {
            'Technology': 'technology',
            'Healthcare': 'healthcare',
            'Financial Services': 'financials',
            'Consumer Cyclical': 'consumer_discretionary',
            'Consumer Defensive': 'consumer_staples',
            'Industrials': 'industrials',
            'Basic Materials': 'materials',
            'Energy': 'energy',
            'Utilities': 'utilities',
            'Real Estate': 'real_estate',
            'Communication Services': 'communication' }
        
        return sector_mapping.get(yf_sector, 'other')
    
    def _get_symbol_themes(self, symbol: str) -> List[str]:
        """Get theme classifications for symbol."""
                pass
        themes = []
        for theme, symbols in self.theme_classifications.items():
            if symbol in symbols:
                themes.append(theme)
        return themes
    
                def _classify_market_cap(self, market_cap: float) -> MarketCap:
        """Classify market capitalization."""
        if market_cap >= 200_000_000_000:
            return MarketCap.MEGA
            elif market_cap >= 10_000_000_000:
            return MarketCap.LARGE
                elif market_cap >= 2_000_000_000:
            return MarketCap.MID
                    elif market_cap >= 300_000_000:
            return MarketCap.SMALL
                        else:
            return MarketCap.MICRO
    
    def _calculate_quality_score(
        self, 
        info: Dict[str, Any], 
        hist: pd.DataFrame ) -> Tuple[float, QualityRating]:
        """Calculate comprehensive quality score."""
                    pass
        
        scores = []
        
        # Financial health score (0-1)
        financial_score = 0.0
        financial_factors = 0
        
        # ROE check
        roe = info.get('returnOnEquity')
    if roe is not None:
            financial_score += min(1.0, max(0.0, roe / 0.25))  # 25% ROE = 1.0
            financial_factors += 1
        
        # Debt-to-equity check
        debt_equity = info.get('debtToEquity')
        if debt_equity is not None:
            financial_score += max(0.0, 1.0 - debt_equity / 2.0)  # Lower debt = higher score
            financial_factors += 1
        
        # Revenue growth
        revenue_growth = info.get('revenueGrowth')
        if revenue_growth is not None:
            financial_score += max(0.0, min(1.0, (revenue_growth + 0.10) / 0.20))
            financial_factors += 1
        
            if financial_factors > 0:
            scores.append(financial_score / financial_factors)
        
        # Valuation score (0-1)
        valuation_score = 0.0
        valuation_factors = 0
        
        # P/E ratio check
        pe_ratio = info.get('trailingPE')
        if pe_ratio is not None and pe_ratio > 0:
            valuation_score += max(0.0, 1.0 - pe_ratio / 50.0)  # Lower P/E = higher score
            valuation_factors += 1
        
        # PEG ratio check
        peg_ratio = info.get('pegRatio')
        if peg_ratio is not None and peg_ratio > 0:
            valuation_score += max(0.0, min(1.0, 2.0 - peg_ratio))  # PEG < 1 is good
            valuation_factors += 1
        
            if valuation_factors > 0:
            scores.append(valuation_score / valuation_factors)
        
        # Liquidity score (0-1)
        liquidity_score = 0.0
        avg_volume = hist['Volume'][-30
    ].mean() if len(hist) >= 30 else hist['Volume'].mean()
        current_price = hist['Close'][-1]
        daily_dollar_volume = avg_volume * current_price
        
        if daily_dollar_volume >= 10_000_000
    # $10M+ = excellent liquidity
            liquidity_score = 1.0
        elif daily_dollar_volume >= 1_000_000
    # $1M+ = good liquidity
            liquidity_score = 0.7
        elif daily_dollar_volume >= 100_000
    # $100k+ = fair liquidity
            liquidity_score = 0.4
        else:
            liquidity_score = 0.1  # Poor liquidity
        
        scores.append(liquidity_score)
        
        # Price stability score (0-1)
        if len(hist) >= 252:  # At least 1 year of data
        returns = hist['Close'].pct_change().dropna()
            volatility = returns.std() * (252 ** 0.5)  # Annualized volatility
            stability_score = max(0.0, 1.0 - volatility / 0.5)  # 50% vol = 0 score
            scores.append(stability_score)
        
        # Calculate overall quality score
        if not scores:
            overall_score = 0.0
            else:
            overall_score = sum(scores) / len(scores)
        
        # Convert to rating
            if overall_score >= 0.8
    rating = QualityRating.EXCELLENT
            elif overall_score >= 0.6
    rating = QualityRating.GOOD
            elif overall_score >= 0.4
    rating = QualityRating.FAIR
            elif overall_score >= 0.2
    rating = QualityRating.POOR
            else:
            rating = QualityRating.EXCLUDED
        
        return overall_score, rating
    
            def _apply_quality_screening(self, stocks: List[StockInfo]) -> List[StockInfo]:
        """Apply quality screening filters."""
        
        quality_stocks = []
        
        for stock in stocks:
            # Basic filters
            if (stock.price < self.min_price or 
                stock.price > self.max_price or
                stock.avg_volume_30d < self.min_avg_volume):
            continue
            
            # Quality rating filter
            if stock.quality_rating == QualityRating.EXCLUDED:
                continue
            
            # Specific metric filters
            if (stock.revenue_growth is not None and 
                stock.revenue_growth < self.quality_thresholds['min_revenue_growth']):
            continue
            
            if (stock.pe_ratio is not None and 
                stock.pe_ratio > self.quality_thresholds['max_pe_ratio']):
            continue
            
            if (stock.roe is not None and 
                stock.roe < self.quality_thresholds['min_roe']):
            continue
            
            if (stock.debt_to_equity is not None and 
                stock.debt_to_equity > self.quality_thresholds['max_debt_to_equity']):
            continue
            
            quality_stocks.append(stock)
        
        self.logger.info(
            f"Quality screening: {len(quality_stocks)}/{len(stocks)} passed" )
        
        return quality_stocks
    
    def _select_final_universe(self, quality_stocks: List[StockInfo]) -> List[StockInfo]:
        """Select final universe with diversification."""
                pass
        
        if len(quality_stocks) <= self.target_universe_size:
            return quality_stocks
        
        # Sort by quality score descending
        quality_stocks.sort(key=lambda s
    s.quality_score, reverse=True)
        
        # Ensure sector diversification
        selected_stocks = []
        sector_counts = {}
        max_per_sector = max(15, self.target_universe_size // len(self.base_universe))
        
        # First pass: select best from each sector
        for stock in quality_stocks:
            sector_count = sector_counts.get(stock.sector, 0)
            if sector_count < max_per_sector:
                selected_stocks.append(stock)
                sector_counts[stock.sector] = sector_count + 1
                
                if len(selected_stocks) >= self.target_universe_size:
                    break
        
        # Second pass: fill remaining slots with highest quality
                    if len(selected_stocks) < self.target_universe_size:
            remaining_stocks = [s for s in quality_stocks if s not in selected_stocks]
            remaining_slots = self.target_universe_size - len(selected_stocks)
            selected_stocks.extend(remaining_stocks[:remaining_slots])
        
        self.logger.info(
            f"Final selection: {len(selected_stocks)} stocks from "
            f"{len(quality_stocks)} quality candidates" )
        
        return selected_stocks
    
        async def _store_universe(self, universe: List[StockInfo]) -> None:
        """Store universe in database."""
        
        # Clear existing universe
        await self.db_manager.execute_query("DELETE FROM stock_universe")
        
        # Insert new universe
        for stock in universe:
            query = """
                INSERT INTO stock_universe 
                (symbol, name, sector, industry, market_cap, market_cap_category,
                 price, volume, avg_volume_30d, pe_ratio, forward_pe, peg_ratio,
                 price_to_book, debt_to_equity, roe, revenue_growth, earnings_growth,
                 beta, dividend_yield, quality_rating, quality_score, themes,
                 exchange, currency, country, employees, website, description,
                 created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, 
                        %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            await self.db_manager.execute_query(query, [
                stock.symbol, stock.name, stock.sector, stock.industry,
                stock.market_cap, stock.market_cap_category.value,
                stock.price, stock.volume, stock.avg_volume_30d,
                stock.pe_ratio, stock.forward_pe, stock.peg_ratio,
                stock.price_to_book, stock.debt_to_equity, stock.roe,
                stock.revenue_growth, stock.earnings_growth, stock.beta,
                stock.dividend_yield, stock.quality_rating.value,
                stock.quality_score, json.dumps(stock.themes),
                stock.exchange, stock.currency, stock.country,
                stock.employees, stock.website, stock.description,
                stock.created_at, stock.updated_at ])
        
        self.logger.info(f"Stored {len(universe)} stocks in database")
    
    def _generate_universe_summary(self, universe: List[StockInfo]) -> Dict[str, Any]:
        """Generate summary statistics for the universe."""
        
        quality_breakdown = {}
        sector_breakdown = {}
        theme_breakdown = {}
        market_cap_breakdown = {}
        
        for stock in universe:
            # Quality breakdown
            quality = stock.quality_rating.value
            quality_breakdown[quality] = quality_breakdown.get(quality, 0) + 1
            
            # Sector breakdown
            sector_breakdown[stock.sector] = sector_breakdown.get(stock.sector, 0) + 1
            
            # Market cap breakdown
            cap_category = stock.market_cap_category.value
            market_cap_breakdown[cap_category] = market_cap_breakdown.get(cap_category, 0) + 1
            
            # Theme breakdown
            for theme in stock.themes:
                theme_breakdown[theme] = theme_breakdown.get(theme, 0) + 1
        
        return {
            'total_stocks': len(universe),
            'quality_breakdown': quality_breakdown,
            'sector_breakdown': sector_breakdown,
            'theme_breakdown': theme_breakdown,
            'market_cap_breakdown': market_cap_breakdown,
            'avg_quality_score': sum(s.quality_score for s in universe) / len(universe),
            'avg_market_cap': sum(s.market_cap for s in universe) / len(universe),
            'total_market_cap': sum(s.market_cap for s in universe) }
    
            async def get_universe_stats(self) -> Dict[str, Any]:
        """Get current universe statistics."""
        try:
            query = """
                SELECT COUNT(*) as total_stocks,
                       AVG(quality_score) as avg_quality_score,
                       AVG(market_cap) as avg_market_cap,
                       SUM(market_cap) as total_market_cap
                FROM stock_universe
            """
            
            result = await self.db_manager.fetch_one(query)
            
            if result:
                return {
                    'total_stocks': result[0],
                    'avg_quality_score': float(result[1]) if result[1] else 0.0,
                    'avg_market_cap': float(result[2]) if result[2] else 0.0,
                    'total_market_cap': float(result[3]) if result[3] else 0.0 }
            
            return {'total_stocks': 0}
            
        except Exception as e:
            self.logger.error(f"Failed to get universe stats: {e}")
            return {'error': str(e)}
    
            async def refresh_universe_data(self, symbols: List[str] = None) -> Dict[str, Any]:
        """Refresh data for specific symbols or entire universe."""
from ...database.core import DatabaseManager
from .stock_data_manager import StockDataManager
from dataclasses import dataclass
from datetime import datetime, timezone, timedelta
from enum import Enum
from typing import Dict, List, Optional, Set, Any, Tuple
import asyncio
import json
import logging
import pandas as pd
import yfinance as yf
try:
    if symbols is None:
                # Get all universe symbols
                query = "SELECT symbol FROM stock_universe"
                rows = await self.db_manager.fetch_all(query)
                symbols = [row[0] for row in rows]
            
            # Re-analyze specified symbols
            updated_stocks = await self._analyze_stocks_batch(symbols, force_refresh=True)
            
            # Update database
        for stock in updated_stocks:
                query = """
                    UPDATE stock_universe SET
                        price = %s, volume = %s, avg_volume_30d = %s,
                        quality_score = %s, quality_rating = %s,
                        updated_at = %s
                    WHERE symbol = %s
                """
                
                await self.db_manager.execute_query(query, [
                    stock.price, stock.volume, stock.avg_volume_30d,
                    stock.quality_score, stock.quality_rating.value,
                    stock.updated_at, stock.symbol ])
            
            # return {
                'success': True,
                'updated_symbols': len(updated_stocks),
                'symbols': [s.symbol for s in updated_stocks] }
            
except Exception as e:
            self.logger.error(f"Failed to refresh universe data: {e}")
            # return {
                'success': False,
                'error': str(e) }